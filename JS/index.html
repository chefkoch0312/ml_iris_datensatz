<!DOCTYPE html>
<html lang="de">

<head>
    <meta charset="utf-8" />
    <title>Iris – TensorFlow.js Demo</title>
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <!-- tf.js CDN -->
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@4.18.0/dist/tf.min.js"></script>
    <style>
        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            line-height: 1.6;
            color: #333;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 1rem;
        }

        .container {
            max-width: 800px;
            margin: 0 auto;
        }

        .header {
            text-align: center;
            margin-bottom: 2rem;
            color: white;
        }

        .title {
            font-size: 2.5rem;
            margin-bottom: 0.5rem;
            font-weight: 700;
        }

        .subtitle {
            font-size: 1.1rem;
            opacity: 0.9;
        }

        .card {
            background: white;
            border-radius: 12px;
            padding: 1.5rem;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.1);
            backdrop-filter: blur(10px);
        }

        .section {
            margin-bottom: 1.5rem;
        }

        .log {
            background: #f8f9fa;
            border: 1px solid #e9ecef;
            border-radius: 8px;
            padding: 1rem;
            font-family: 'Courier New', monospace;
            font-size: 0.9rem;
            white-space: pre-line;
            max-height: 100px;
            overflow-y: auto;
            color: #495057;
        }

        .grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 1rem;
            margin-bottom: 1.5rem;
            align-items: center;
        }

        label {
            font-weight: 500;
            color: #495057;
        }

        input {
            padding: 0.5rem;
            border: 2px solid #e9ecef;
            border-radius: 6px;
            font-size: 1rem;
            transition: border-color 0.2s;
        }

        input:focus {
            outline: none;
            border-color: #667eea;
        }

        .actions {
            display: flex;
            align-items: center;
            gap: 1rem;
            margin-bottom: 1rem;
        }

        button {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border: none;
            padding: 0.75rem 1.5rem;
            border-radius: 6px;
            font-size: 1rem;
            cursor: pointer;
            transition: transform 0.2s, box-shadow 0.2s;
        }

        button:hover:not(:disabled) {
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(102, 126, 234, 0.4);
        }

        button:disabled {
            background: #6c757d;
            cursor: not-allowed;
        }

        .mono {
            font-family: 'Courier New', monospace;
            font-size: 0.9rem;
        }

        .pill {
            background: #e9ecef;
            padding: 0.2rem 0.5rem;
            border-radius: 12px;
            font-size: 0.8rem;
            margin-left: 0.5rem;
            color: #495057;
        }

        .footer {
            font-size: 0.9rem;
            color: #6c757d;
            line-height: 1.4;
        }

        .warn {
            color: #fd7e14;
            font-weight: 500;
        }

        .kpi {
            color: #28a745;
            font-weight: 500;
        }

        h3 {
            color: #495057;
            margin-bottom: 1rem;
        }

        @media (max-width: 600px) {
            .title {
                font-size: 2rem;
            }

            .grid {
                grid-template-columns: 1fr;
            }

            .actions {
                flex-direction: column;
                align-items: flex-start;
                gap: 0.5rem;
            }
        }
    </style>
</head>

<body>
    <div class="container">
        <header class="header">
            <h1 class="title">Iris – Klassifikation (tf.js)</h1>
        </header>

        <section class="card section">
            <div id="log" class="log">Lade Daten…</div>
        </section>

        <section class="card section">
            <h3 style="margin:.2rem 0 1rem">Vorhersage</h3>
            <div class="grid">
                <label for="sl">Sepal length (cm)</label><input id="sl" type="number" step="0.1" value="5.1">
                <label for="sw">Sepal width (cm)</label><input id="sw" type="number" step="0.1" value="3.5">
                <label for="pl">Petal length (cm)</label><input id="pl" type="number" step="0.1" value="1.4">
                <label for="pw">Petal width (cm)</label><input id="pw" type="number" step="0.1" value="0.2">
            </div>
            <p class="actions">
                <button id="predictBtn" disabled>Vorhersagen</button>
                <span id="predOut" class="mono"></span>
            </p>
            <p class="footer">Tipp: Nach dem Training oben erscheinen Loss/Accuracy-Logs. <span
                    class="warn">Validation</span> & <span class="kpi">Test</span> werden getrennt berechnet.</p>
        </section>
    </div>

    <script>
        (async () => {
            const logEl = document.getElementById('log');
            const predictBtn = document.getElementById('predictBtn');
            const predOut = document.getElementById('predOut');
            const inputs = ['sl', 'sw', 'pl', 'pw'].map(id => document.getElementById(id));

            const LABELS = ['setosa', 'versicolor', 'virginica'];
            const CSV_URL = 'https://kado-ber.de/ml_iris_datensatz/js/iris.csv';

            const log = (s) => { logEl.textContent += (logEl.textContent ? '\n' : '') + s; };

            const csvToArrays = (csvText) => {
                const lines = csvText.trim().split(/\r?\n/);
                const header = lines.shift().split(',');
                const speciesIdx = header.indexOf('species');
                const X = [], y = [];
                for (const line of lines) {
                    const cols = line.split(',');
                    X.push([+cols[0], +cols[1], +cols[2], +cols[3]]);
                    y.push(cols[speciesIdx]);
                }
                return { X, y };
            }
            const labelToIndex = s => LABELS.indexOf(s);

            try {
                // 1) Daten laden
                const res = await fetch(CSV_URL);
                const txt = await res.text();
                const { X, y } = csvToArrays(txt);

                // 2) Shuffle + Train/Test Split
                const idx = X.map((_, i) => i);
                for (let i = idx.length - 1; i > 0; i--) {
                    const j = Math.floor(Math.random() * (i + 1));
                    [idx[i], idx[j]] = [idx[j], idx[i]];
                }
                const Xs = idx.map(i => X[i]);
                const ys = idx.map(i => labelToIndex(y[i]));
                const nTrain = Math.floor(0.8 * Xs.length);

                const Xtrain = Xs.slice(0, nTrain);
                const ytrain = ys.slice(0, nTrain);
                const Xtest = Xs.slice(nTrain);
                const ytest = ys.slice(nTrain);

                // 3) Normalisieren (float32!)
                const xTrainTf = tf.tensor2d(Xtrain, [Xtrain.length, 4], 'float32');
                const xTestTf = tf.tensor2d(Xtest, [Xtest.length, 4], 'float32');

                const mean = xTrainTf.mean(0);
                const std = xTrainTf.sub(mean).square().mean(0).sqrt();

                const norm = (t2d) => t2d.sub(mean).div(std);

                const xTr = norm(xTrainTf);
                const yTr = tf.tensor1d(ytrain, 'float32');
                const xTe = norm(xTestTf);
                const yTe = tf.tensor1d(ytest, 'float32');

                // 4) Modell
                const model = tf.sequential();
                model.add(tf.layers.dense({ units: 16, activation: 'relu', inputShape: [4] }));
                model.add(tf.layers.dense({ units: 16, activation: 'relu' }));
                model.add(tf.layers.dense({ units: 3, activation: 'softmax' }));
                model.compile({
                    optimizer: tf.train.adam(0.02),
                    loss: 'sparseCategoricalCrossentropy',
                    metrics: ['accuracy']
                });

                // 5) Training
                log('Training startet …');
                await model.fit(xTr, yTr, {
                    epochs: 120,
                    batchSize: 16,
                    shuffle: true,
                    validationSplit: 0.15,
                    callbacks: {
                        onEpochEnd: (epoch, logs) => {
                            if (epoch % 10 === 0) {
                                log(`Epoch ${String(epoch).padStart(3)} — loss ${logs.loss.toFixed(3)} — acc ${logs.acc.toFixed(3)}`);
                            }
                        }
                    }
                });

                // 6) Evaluierung
                const evalRes = model.evaluate(xTe, yTe, { batchSize: 16, verbose: 0 });
                const [testLoss, testAcc] = await Promise.all(evalRes.map(t => t.data()));
                log(`\nTest: loss ${testLoss[0].toFixed(3)} — accuracy ${(testAcc[0] * 100).toFixed(1)}%`);

                // 7) Vorhersage
                predictBtn.disabled = false;
                predictBtn.addEventListener('click', () => {
                    const vals = inputs.map(el => parseFloat(el.value));
                    if (vals.some(v => Number.isNaN(v))) return;
                    tf.tidy(() => {
                        const x = tf.tensor2d([vals], [1, 4], 'float32').sub(mean).div(std);
                        const probs = model.predict(x).dataSync();
                        const best = probs.reduce((bi, p, i) => (p > probs[bi] ? i : bi), 0);
                        const pretty = LABELS.map((lab, i) => `${lab}<span class="pill">${(probs[i] * 100).toFixed(1)}%</span>`).join('  ');
                        predOut.innerHTML = `→ ${LABELS[best]}  |  ${pretty}`;
                    });
                });

                // cleanup
                window.addEventListener('beforeunload', () => {
                    xTr.dispose(); yTr.dispose(); xTe.dispose(); yTe.dispose();
                    model.dispose(); mean.dispose(); std.dispose();
                });

                log('Bereit. Werte eingeben und „Vorhersagen" klicken.');
            } catch (e) {
                log('Fehler beim Laden/Trainieren: ' + e.message);
                console.error(e);
            }
        })();
    </script>
</body>

</html>